package com.liuxin.concurrency3;

/**
 * synchronized关键字的使用说明(一般同步代码块用的比较多)
 * JVM中的同步是基于进入与退出监视器对象（管程对象）（Monitor）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象会和java
 * 对象一同创建并销毁。Monitor对象是由C++来实现的。
 *
 * 当多个线程同时访问一段同步代码时，这些线程会被放到一个EntryList集合中，处于阻塞状态的线程都会被放到该列表当中。接下来，当线程获取到对象
 * 的Monitor时，Monitor是依赖于底层操作系统的mutex lock来实现互斥的，线程获取mutex成功，则会持有该mutex，这时其他线程就无法在获取到该
 * mutex
 *
 * 如果线程调用了wait方法，那么该线程就会释放掉所持有的mutex，并且该线程会进入到waitSet集合（等待集合）中，等待下一次被其他线程调用notify/notifyAll
 * 唤醒。如果当前线程顺序执行完毕方法，那么她也会释放掉所持有的mutex
 *
 * 总结一下：同步锁在这种实现方式当中，因为Monitor是依赖于底层的操作系统实现，这样就存在用户太与内核太之间的切换，所以会增加性能开销。
 *
 * 通过对象互斥锁的概念来保证共享数据操作的完整性。每个对象都对应一个可称为（互斥锁）的标记，这个标记用于保证在任何时刻，只能有一个线程方位该对象。
 *
 * 那些处于EntryList与WaitList中的线程均处于阻塞状态，阻塞操作是有操作系统来完成的，在Linux下通过pthread_mutex_lock函数实现的，线程被阻塞后便
 * 会进入到内核调度状态，这会导致系统在用户太和内核态之间来回切换，严重影响锁的性能。
 *
 * 解决上述问题的办法便是自旋，其原理是：当发生对Monitor的争用时，若owner能够在很短的时间内释放掉锁，则呢些正在争用的线程就可以稍微等待一下（即所谓的自旋（spin））
 * ，在owner线程释放锁之后，争用线程可能会立即获得锁，从而避免了系统阻塞。不过，当owner运行的时间超过了临界值后，争用线程自旋一段时间后依然无法获取到锁，这时
 * 争用线程则会停止自旋而进入阻塞状态，所以总的来说：先自旋，不成功再进行阻塞，尽量降低阻塞的可能性（应为阻塞的成本是非常高的），这对那些执行时间短的代码块来说
 * 有极大的性能提升。显然，自旋在多处理器（多核心）才有意义
 *
 * 修饰代码块、修饰普通示例方法（访问修饰方法）、修饰静态方法（有没有static锁的对象是不一样的）
 *
 * 互斥锁的属性：
 * 1.PTHREAD_MUTEX_TIMED_NP:这时缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将会形成一个等待队列，并且在解锁后按照优先级获取到锁，
 *   这种策略可以确保资源分配的公平性。
 * 2.PTHREAD_MUTEX_RECURSIVE_NP:嵌套锁。允许一个线程对同一个锁成功获取多次，并通过unlock解锁。如果是不同线程请求，则在加锁线程解锁式重新进行竞争。
 * 3.PTHREAD_MUTEX_ERRORCHECK_NP:检错锁。如果一个线程请求同一个锁，则返回EDEADLK，否则与第一种类型动作相同，这样就保证了当不允许多次加锁时
 *  不会出现最简单情况下的死锁。
 * 4.PTHREAD_MUTEX_ADAPTIVE_NP:适应锁，动作最简单的锁类型，仅仅等待解锁后重新竞争。
 *
 * synchronize是通过语言的方式来实现同步，lock方法（组件方法）。
 * synchronize是通过操作系统来实现的。（阻塞，什么的是通过操作系统来实现的，比如映射到什么函数什么的）
 *
 * 源码之前，了无秘密。
 * openjdk:
 *
 * jdk1.5之前如果想实现线程同步只能通过synchronize关键字这一种方式来打成，底层，java也是通过synchronized关键字来做到数据的原子性维护的，
 * synchronized关键字是JVM实现的一种内置锁，从底层角度来说，这种锁的获取与释放都是由JVM帮助我们隐式实现的。
 *
 * 从jdk1.5开始，并发包引入了lock锁，Lock同步锁是基于java来实现的，因此锁的获取与释放都是通过java代码来实现与控制的，然而synchronized
 * 是基于底层操作系统的Mutex Lock来实现的，每次对锁的获取与释放都会带来用户态与内核态之间的切换，这种切换会几大地增加系统的负担。所以当并发量
 * 较高时，也就是锁的竞争比较激烈时，synchronized锁在性能上的表现就非常差。
 *
 * 从JDK 1.6开始，synchronized锁的实现发生了很大的变化;JVw引入了相应的优化手段来提升synchronized锁的性能，
 * 这种提升涉及到偏向锁、轻量级锁及重量级锁等，从而减少锁的竞争所带来的用户态与内核态之间的切换，这种锁的优化实际上是通过Java对象头中的一些标志位来去实现的，
 * 对于锁的访问与改变,实际上都与Java对象头息息相关。
 *
 * 从JDK 1.6开始，对象实例在堆当中会被划分为三个组成部分︰对象头、实例数据与对齐填充。对象头主要也是由3块内容来构成:
 * 1。Mark word
 * 2。指向类的指针
 * 3。数组长度
 *
 * 其中Mark Word(它记录了对象、锁及垃圾回收相关的信息，在64位的TvVW中，其长度也是64bit)的位信息包括了如下组成部分:
 * 1。无锁标记
 * 2。偏向锁标记
 * 3。轻量级锁标记
 * 4。重量级锁标记
 * 5.cc标记
 *
 * 对于synchronized锁来说，锁的升级主要都是通过Nark Mord中的锁标志位与是否是偏向锁标志位来沽成的;synchronized关键字所对应的锁都是先从偏向锁开始，
 * 随着锁竞争的不断升级，逐步演化至轻量级锁，最后则变成了重量级锁。
 *
 * 对于锁的演化来说,它会经历如下阶段:
 * 无锁->偏向锁-→>轻量级锁（轻量性锁的一种解决方式）->重量级锁
 *
 * 偏向锁:（偏向与上一次访问的线程）
 *
 * 针对于一个线程来说的，它的主要作用就是优化同一个线程多次获取一个锁的情况;如果一个synchronized方法被一个线程访问，那么这个方法所在的对象
 * 就会在其Mark Word中的将偏向锁进行标记，同时还会有一个字段来存储该线程的ID;当这个线程再次访问同一个synchronized方法时，
 * 它会检查这个对象的Mark Word的偏向锁标记以及是否指向了其线程D，如果是的话，那么该线程就无需再去进入管程(Monitor)了，而是直接进入到该方法体中.
 * 如果是另外一个线程访问这个synchronized方法，那么实际情况会如何呢? 偏向锁会被取消掉。（并发量比较大的时候，开销更加大）
 *
 * 轻量级锁:（轮流进行）
 *
 * 若第一个线程已经获取到了当前对象的锁，这时第二个线程又开始尝试争抢该对象的锁，由于该对象的锁已经被第一个线程获取到，
 * 因此它是偏向锁，而第二个线程在争抢时，会发现该对象头中的Mark Word已经是偏向锁，但里面存储的线程zb并不是自己(是第一个线程)，
 * 那么它会进行cas (compare and Swap) ,从而获取到锁,这里面存在两种情况:
 * 1。获取锁成功:那么它会直接将Mark Word中的线程工p由第一个线程变成自己(偏向锁标记位保持不变)，这样该对象依然会保持偏向锁的状态。
 * 2．获取锁失败:则表示这时可能会有多个线程同时在尝试争抢该对象的锁，那么这时偏向锁就会进行升级，升级为轻量级锁
 *
 * 自旋锁:（有次数的限制,轻量级锁的实现方式）
 * 若自旋失败（依然无法获取到锁)，那么锁就会转化为重量级锁，在这种情况下，无法获取到锁的线程都会进入到Monitor(即内核态)
 * 自旋最大的一个特点就是避免了线程从用户态进入到内核态。
 *
 * 重量级锁:
 * 线程最终从用户态进入到了内核态。
 *
 * 粒度（concurrentHashMap）
 *
 *
 * @author leany
 * @date 2020/11/9 13:40
 */
public class MyTest3 {
    private Object object = new Object();

    public void method(){
        // 为什么使用任何对象都行？，如果获取到锁的时候就可以执行，否则就阻塞，本质上用任何对象都行。
        synchronized (object){
            System.out.println("hello word");
        }
    }

}
